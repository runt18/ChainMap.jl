{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl\n\n\n\n\nChainMap.Arguments\n\n\nChainMap.LazyCall\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nChainMap.bitnot\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain_map\n\n\nChainMap.collect_arguments\n\n\nChainMap.collect_call\n\n\nChainMap.lambda\n\n\nChainMap.lambda\n\n\nChainMap.lambda\n\n\nChainMap.lazy_call\n\n\nChainMap.nonstandard\n\n\nChainMap.push\n\n\nChainMap.push\n\n\nChainMap.unshift\n\n\nChainMap.unshift\n\n\nChainMap.unweave\n\n\nChainMap.unweave\n\n\nChainMap.unweave\n\n\nChainMap.with\n\n\nChainMap.@chain\n\n\nChainMap.@chain_map\n\n\nChainMap.@lambda\n\n\nChainMap.@lazy_call\n\n\nChainMap.@nonstandard\n\n\nChainMap.@unweave\n\n\nChainMap.@with\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\ntype Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use.\n\n\nCreate with \ncollect_arguments\n. You can also \nmerge\n two \nArguments\n, \npush\n or \nunshift\n in new arguments, and run with \nrun\n.\n\n\nsource\n\n\n#\n\n\nChainMap.LazyCall\n \n \nType\n.\n\n\ntype LazyCall{T \n: Function}\n    arguments::Arguments\n    function_call::T\nend\n\n\n\n\n\nWill store a function along with its arguments for later use. Create with \ncollect_call\n and run with \nrun\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments, f::Function)\n\n\n\n\n\nCall \nf\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nrun\n(\n_\n,\n \nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments)\n\n\n\n\n\nCall \nrun\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \ncollect_arguments\n(\n_\n,\n \nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall, f::Function)\n\n\n\n\n\nInsert \nl.function_call\n as the first positional argument in \nl.arguments\n, the standard position for functional programming, then \nrun\n \nf\n on the result.\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n4\n])\n\n    \nLazyCall\n(\n_\n,\n \nvcat\n)\n\n    \nrun\n(\n_\n,\n \nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall)\n\n\n\n\n\nCall \nl.function_call\n on the \nArguments\n in \nl.arguments\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@unweave\n\n\nExamples\n\n\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain es...\n\n\n\n\n\nreduce\n \n@chain\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n_\n,\n \n2\n)\n \nvcat\n(\n_\n,\n \n3\n)\n \n)\n \n==\n\n    \n@\nchain\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n_\n,\n \n2\n)\n \n)\n \nvcat\n(\n_\n,\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail\n\n\n\n\n\nCalls \nhead\n on \ntail\n\n\nExamples\n\n\n@\ntest\n \nvcat\n(\n1\n)\n \n==\n \n@\nchain\n \n1\n \nvcat\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail::Expr\n\n\n\n\n\nReinterprets \n_\n in \ntail\n as \nhead\n.\n\n\nExamples\n\n\n@\ntest\n \nvcat\n(\n2\n,\n \n1\n)\n \n==\n \n@\nchain\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain e\n\n\n\n\n\nSeparate single begin blocks out into lines and \nchain\n them; return single non-blocks.\n\n\nExamples\n\n\n@\ntest\n \n1\n \n==\n \n@\nchain\n \n1\n\n\n\nchain_block\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \nvcat\n(\n_\n,\n \n2\n)\n\n\nend\n\n\n\n@\ntest\n \nchain_block\n \n==\n \n@\nchain\n \n1\n \nvcat\n(\n_\n,\n \n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain_map\n \n \nFunction\n.\n\n\n@chain_map(e, v = _)\n\n\n\n\n\nThe \n@chain_map\n macro combines three different macros. \nwith\n annotates each symbol with the associative: \nv\n. \nchain\n chains together expressions wrapped in a \nbegin\n block. \nunweave\n, together with \nNullableArrays.broadcast(lift = true)\n, does broadcasting and automatic lifting of woven expressions.\n\n\nExamples\n\n\nna\n \n=\n  \nNullableArrays\n.\nNullableArray\n\n\na\n \n=\n \nna\n([\none\n,\n \ntwo\n],\n \n[\nfalse\n,\n \ntrue\n])\n\n\nresult\n \n=\n \n@\nchain\n \nbegin\n\n    \nDict\n(:\nb\n \n=\n \nna\n([\n1\n,\n \n2\n]),\n \n:\nc\n \n=\n \nna\n([\nI\n,\n \nII\n]))\n\n    \n@\nchain_map\n \nbegin\n\n        \n:\nb\n\n        \nsum\n\n        \nget\n\n        \nstring\n\n        \n*\n(\n~\na\n,\n \n \n,\n \n_\n,\n \n \n,\n \n~\n:\nc\n)\n\n    \nend\n\n\nend\n\n\n\n@\ntest\n \nget\n(\nresult\n[\n1\n])\n \n==\n \none 3 I\n\n\n@\ntest\n \nresult\n.\nisnull\n \n==\n \n[\nfalse\n,\n \ntrue\n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_arguments\n \n \nMethod\n.\n\n\ncollect_arguments(positional...; keyword...)\n\n\n\n\n\nEasy way to build an \nArguments\n type.\n\n\nExamples\n\n\na\n \n=\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n@\ntest\n \na\n.\npositional\n \n==\n \n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \na\n.\nkeyword\n \n==\n \nDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_call\n \n \nMethod\n.\n\n\ncollect_call\n(\nf\n:\n:Function\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nEasy way to build a \nLazyCall\n type.\n\n\nExamples\n\n\nl\n \n=\n \ncollect_call\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n@\ntest\n \nl\n.\nfunction_call\n \n==\n \nvcat\n\n\n@\ntest\n \nl\n.\narguments\n \n==\n \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nFunction\n.\n\n\n@lambda(f, e, v = :_)\n\n\n\n\n\nlambda\n \ne\n then call \nf\n on \ne\n and \nv\n.\n\n\nExamples\n\n\nf\n \n=\n \n:\nmap\n\n\ne\n \n=\n \n:(\nvcat\n(\n_\n,\n \n1\n))\n\n\nlambda\n(\nf\n,\n \ne\n)\n\n\n\n_\n \n=\n \n[\n1\n,\n \n2\n]\n\n\n@\ntest\n \n[[\n1\n,\n \n1\n],\n \n[\n2\n,\n \n1\n]]\n \n==\n \n@\nlambda\n \nmap\n \nvcat\n(\n_\n,\n \n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nFunction\n.\n\n\n@unweave(f::Expr, e, v = :_)\n\n\n\n\n\nlambda\n \ne\n then insert \ne\n as as the first and \nv\n as the last argument to \nf\n.\n\n\nf\n must be a call.\n\n\nExamples\n\n\ne\n \n=\n \n:(\n_\n \n+\n \n1\n)\n\n\nf\n \n=\n \n:(\nNullableArrays\n.\nmap\n(\nlift\n \n=\n \ntrue\n))\n\n\n\nlambda\n(\nf\n,\n \ne\n)\n\n\n\n_\n \n=\n \nNullableArrays\n.\nNullableArray\n([\n1\n,\n \n2\n],\n \n[\nfalse\n,\n \ntrue\n])\n\n\n\nresult\n \n=\n \n@\nlambda\n \nNullableArrays\n.\nbroadcast\n(\nlift\n \n=\n \ntrue\n)\n \n_\n \n+\n \n1\n\n\n\n@\ntest\n \nresult\n.\nvalues\n[\n1\n]\n \n==\n \n2\n\n\n@\ntest\n \nresult\n.\nisnull\n \n==\n \n[\nfalse\n,\n \ntrue\n]\n\n\n\n# `f` must be a call\n\n\n@\ntest_throws\n \nErrorException\n \nlambda\n(:(\nimport\n \nChainMap\n),\n \n:(\n_\n \n+\n \n1\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nMethod\n.\n\n\n@lambda e\n\n\n\n\n\nConvert \ne\n to an anonymous function with \n_\n as the input variable.\n\n\nExamples\n\n\nlambda_function\n \n=\n \n@\nlambda\n \nvcat\n(\n_\n,\n \n2\n)\n\n\n@\ntest\n \nlambda_function\n(\n1\n)\n \n==\n \nvcat\n(\n1\n,\n \n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lazy_call\n \n \nMethod\n.\n\n\n@lazy_call(e)\n\n\n\n\n\nWill break apart a function call into a \nLazyCall\n object.\n\n\nExamples\n\n\ntest_function\n(\narguments\n...\n;\n \nkeyword_arguments\n...\n)\n \n=\n\n    \n(\narguments\n,\n \nkeyword_arguments\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \ntest_function\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n \n)\n \n==\n\n    \ncollect_call\n(\ntest_function\n,\n \n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.nonstandard\n \n \nMethod\n.\n\n\n@nonstandard(fs...)\n\n\n\n\n\nWill create a nonstandard evaluation macro for each of the \nfs\n functions.\n\n\nEach function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.\n\n\nExamples\n\n\nbinaryfun\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \nExpr\n(:\ncall\n,\n \nb\n,\n \na\n,\n \nc\n)\n\n\nchainback\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \nExpr\n(:\ncall\n,\n \nc\n,\n \nb\n,\n \na\n)\n\n\n\n@\nnonstandard\n \nbinaryfun\n \nchainback\n\n\n\n@\ntest\n \nvcat\n(\n1\n,\n \n2\n)\n \n==\n \n@\nbinaryfun\n \n1\n \nvcat\n \n2\n\n\n@\ntest\n \nvcat\n(\n3\n,\n \n2\n)\n \n==\n \n@\nchainback\n \n2\n \n3\n \nvcat\n\n\n\n@\ntest\n \nSee documentation of [`binaryfun`](@ref)\n \n==\n\n    \n@\nchain\n \n(@\ndoc\n \n@\nbinaryfun\n)\n \nstring\n \nchomp\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to \narguments\n.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \npush\n(\n_\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\nlazy_call\n:\n:LazyCall\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\npush\n to \nlazy_call.arguments\n.\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \npush\n(\n_\n,\n \n[\n3\n,\n \n4\n])\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \n[[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n4\n]]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to \narguments\n.\n\n\nNew arguments are added at the start.\n\n\nExamples\n\n\nunshift_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n    \nunshift\n(\n_\n,\n \n1\n)\n\n\nend\n\n\n\n@\ntest\n \nunshift_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(lazy_call::LazyCall, positional...)\n\n\n\n\n\nunshift\n to \nlazy_call.arguments\n.\n\n\nExamples\n\n\nunshift_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nunshift_test\n \n==\n \n[[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n4\n]]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave f e\n\n\n\n\n\nunweave\n \ne\n then run \nf\n on the component parts.\n\n\nIf there are no woven arguments in \ne\n, return \ne\n.\n\n\nExamples\n\n\n@\ntest\n \n1\n \n==\n \n@\nunweave\n \n1\n \n1\n\n\n@\ntest\n \n1\n \n==\n \n@\nunweave\n \n1\n \n+\n(\n1\n)\n\n\n\ne\n \n=\n \n:(\nvcat\n(\n~\na\n,\n \n~\nb\n)\n \n)\n\n\nf\n \n=\n \n:\nbroadcast\n\n\nunweave\n(\nf\n,\n \ne\n)\n\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n[\n3\n,\n \n4\n]\n\n\n\n@\ntest\n \nbroadcast\n((\na\n,\n \nb\n)\n \n-\n \nvcat\n(\na\n,\n \nb\n),\n \na\n,\n \nb\n)\n \n==\n\n    \n@\nunweave\n \nbroadcast\n \nvcat\n(\n~\na\n,\n \n~\nb\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave f::Expr e\n\n\n\n\n\nunweave\n \ne\n then insert the function as the first argument to \nf\n and the woven arguments at the end of the arguments of \nf\n.\n\n\nIf there are no woven arguments in \ne\n, return \ne\n.\n\n\nExamples\n\n\n@\ntest\n \n1\n \n==\n \n@\nunweave\n \n+\n(\n1\n)\n \n1\n\n\n@\ntest\n \n1\n \n==\n \n@\nunweave\n \n+\n(\n1\n)\n \n+\n(\n1\n)\n\n\n\ne\n \n=\n \n:(\n~\na\n \n+\n \n~\nb\n)\n\n\nf\n \n=\n \n:(\nNullableArrays\n.\nbroadcast\n(\nlift\n \n=\n \ntrue\n))\n\n\n\nunweave\n(\nf\n,\n \ne\n)\n\n\n\na\n \n=\n \nNullableArrays\n.\nNullableArray\n([\n1\n,\n \n2\n])\n\n\nb\n \n=\n \nNullableArrays\n.\nNullableArray\n([\n3\n,\n \n4\n],\n \n[\nfalse\n,\n \ntrue\n])\n\n\n\nresult\n \n=\n \n@\nunweave\n \nbroadcast\n(\nlift\n \n=\n \ntrue\n)\n \n~\na\n \n+\n \n~\nb\n\n\n\n@\ntest\n \nresult\n.\nvalues\n[\n1\n]\n \n==\n \n4\n\n\n@\ntest\n \nresult\n.\nisnull\n \n==\n \n[\nfalse\n,\n \ntrue\n]\n\n\n\n# `f` must be a call\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\nimport\n \nChainMap\n),\n \n:(\n~\n_\n \n+\n \n1\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave e\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. No more than one splatted positional argument can be woven in. No more than one splatted keyword argument can be woven in provided there is a \n;\n visible both inside and outside the tilda. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n. If there are no woven arguments in \ne\n, return \ne\n.\n\n\nExamples\n\n\n@\ntest\n \n1\n \n==\n \n@\nunweave\n \n1\n\n\n@\ntest\n \n1\n \n==\n \n@\nunweave\n \n+\n(\n1\n)\n\n\n\nA\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nB\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\nunweave_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n@\nunweave\n \nvcat\n(\n~\nA\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nB\n...\n)\n \n)\n\n    \nrun\n(\n_\n,\n \nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nunweave_test\n \n==\n\n      \nmap\n((\na\n,\n \nc\n,\n \nb\n...\n)\n \n-\n \nvcat\n(\na\n,\n \nc\n,\n \nb\n...\n),\n \nA\n,\n \n[\n3\n,\n \n4\n],\n \nB\n...\n)\n\n\n\nkeyword_test\n(;\n \nkeyword_arguments\n...\n)\n \n=\n \nkeyword_arguments\n\n\n\na\n \n=\n \nkeyword_test\n(\na\n \n=\n \n1\n,\n \nb\n \n=\n \n2\n)\n\n\n\nunweave_keyword_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n@\nunweave\n \nkeyword_test\n(\nc\n \n=\n \n3\n;\n \n~\n(\na\n...\n))\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nunweave_keyword_test\n \n==\n \nkeyword_test\n(\nc\n \n=\n \n3\n;\n \na\n...\n \n)\n\n\n\n# Can splat no more than one positional argument\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\n \n~\n(\na\n...\n)\n \n+\n \n~\n(\nb\n...\n)\n \n))\n\n\n\n# Can splat no more than one keyword argument\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\n \n~\n(;\na\n...\n)\n \n+\n \n~\n(;\nb\n...\n)\n \n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.with\n \n \nFunction\n.\n\n\n@with(e, df = _)\n\n\n\n\n\nExtract any symbols \ne\n, such as \n:colA\n, from \ndf\n, e.g. \ndf[:colA]\n.\n\n\nAnything wrapped in \n^\n, such as \n^(expr)\n, gets passed through untouched.\n\n\nExamples\n\n\na\n \n=\n \n1\n\n\n_\n \n=\n \nDataFrames\n.\nDataFrame\n(\na\n \n=\n \n2\n)\n\n\n\n@\ntest\n \nDataFrames\n.\nDataFrame\n(\nb\n \n=\n \n_\n[:\na\n]\n \n+\n \na\n,\n \nc\n \n=\n \n:\nd\n)\n \n==\n\n   \n@\nwith\n \nDataFrames\n.\nDataFrame\n(\nb\n \n=\n \n:\na\n \n+\n \na\n,\n \nc\n \n=\n \n^\n(:\nd\n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\nSee documentation of \nchain\n\n\nsource\n\n\n#\n\n\nChainMap.@chain_map\n \n \nMacro\n.\n\n\nSee documentation of \nchain_map\n\n\nsource\n\n\n#\n\n\nChainMap.@lambda\n \n \nMacro\n.\n\n\nSee documentation of \nlambda\n\n\nsource\n\n\n#\n\n\nChainMap.@lazy_call\n \n \nMacro\n.\n\n\nSee documentation of \nlazy_call\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\nSee documentation of \nnonstandard\n\n\nsource\n\n\n#\n\n\nChainMap.@unweave\n \n \nMacro\n.\n\n\nSee documentation of \nunweave\n\n\nsource\n\n\n#\n\n\nChainMap.@with\n \n \nMacro\n.\n\n\nSee documentation of \nwith\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl", 
            "text": "ChainMap.Arguments  ChainMap.LazyCall  Base.run  Base.run  Base.run  Base.run  ChainMap.bitnot  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.chain_map  ChainMap.collect_arguments  ChainMap.collect_call  ChainMap.lambda  ChainMap.lambda  ChainMap.lambda  ChainMap.lazy_call  ChainMap.nonstandard  ChainMap.push  ChainMap.push  ChainMap.unshift  ChainMap.unshift  ChainMap.unweave  ChainMap.unweave  ChainMap.unweave  ChainMap.with  ChainMap.@chain  ChainMap.@chain_map  ChainMap.@lambda  ChainMap.@lazy_call  ChainMap.@nonstandard  ChainMap.@unweave  ChainMap.@with   #  ChainMap.Arguments     Type .  type Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend  Will store positional and keyword arguments for later use.  Create with  collect_arguments . You can also  merge  two  Arguments ,  push  or  unshift  in new arguments, and run with  run .  source  #  ChainMap.LazyCall     Type .  type LazyCall{T  : Function}\n    arguments::Arguments\n    function_call::T\nend  Will store a function along with its arguments for later use. Create with  collect_call  and run with  run  source  #  Base.run     Method .   run(a::Arguments, f::Function)  Call  f  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( _ ,   vcat ) \n     run ( _ ,   map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(a::Arguments)  Call  run  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( _ ,   vcat ) \n     collect_arguments ( _ ,   map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall, f::Function)  Insert  l.function_call  as the first positional argument in  l.arguments , the standard position for functional programming, then  run   f  on the result.  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 , 4 ]) \n     LazyCall ( _ ,   vcat ) \n     run ( _ ,   map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall)  Call  l.function_call  on the  Arguments  in  l.arguments  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( _ ,   vcat ) \n     LazyCall ( _ ,   map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @unweave  Examples  @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.chain     Method .  @chain es...  reduce   @chain  over  es  Examples  @ test   (   @ chain   1   vcat ( _ ,   2 )   vcat ( _ ,   3 )   )   == \n     @ chain   (   @ chain   1   vcat ( _ ,   2 )   )   vcat ( _ ,   3 )   source  #  ChainMap.chain     Method .  @chain head tail  Calls  head  on  tail  Examples  @ test   vcat ( 1 )   ==   @ chain   1   vcat   source  #  ChainMap.chain     Method .  @chain head tail::Expr  Reinterprets  _  in  tail  as  head .  Examples  @ test   vcat ( 2 ,   1 )   ==   @ chain   1   vcat ( 2 ,   _ )   source  #  ChainMap.chain     Method .  @chain e  Separate single begin blocks out into lines and  chain  them; return single non-blocks.  Examples  @ test   1   ==   @ chain   1  chain_block   =   @ chain   begin \n     1 \n     vcat ( _ ,   2 )  end  @ test   chain_block   ==   @ chain   1   vcat ( _ ,   2 )   source  #  ChainMap.chain_map     Function .  @chain_map(e, v = _)  The  @chain_map  macro combines three different macros.  with  annotates each symbol with the associative:  v .  chain  chains together expressions wrapped in a  begin  block.  unweave , together with  NullableArrays.broadcast(lift = true) , does broadcasting and automatic lifting of woven expressions.  Examples  na   =    NullableArrays . NullableArray  a   =   na ([ one ,   two ],   [ false ,   true ])  result   =   @ chain   begin \n     Dict (: b   =   na ([ 1 ,   2 ]),   : c   =   na ([ I ,   II ])) \n     @ chain_map   begin \n         : b \n         sum \n         get \n         string \n         * ( ~ a ,     ,   _ ,     ,   ~ : c ) \n     end  end  @ test   get ( result [ 1 ])   ==   one 3 I  @ test   result . isnull   ==   [ false ,   true ]   source  #  ChainMap.collect_arguments     Method .  collect_arguments(positional...; keyword...)  Easy way to build an  Arguments  type.  Examples  a   =   collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  @ test   a . positional   ==   ( 1 ,   2 )  @ test   a . keyword   ==   Dict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  ChainMap.collect_call     Method .  collect_call ( f : :Function ,   positional ...;   keyword ...)   Easy way to build a  LazyCall  type.  Examples  l   =   collect_call ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])  @ test   l . function_call   ==   vcat  @ test   l . arguments   ==   collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.lambda     Function .  @lambda(f, e, v = :_)  lambda   e  then call  f  on  e  and  v .  Examples  f   =   : map  e   =   :( vcat ( _ ,   1 ))  lambda ( f ,   e )  _   =   [ 1 ,   2 ]  @ test   [[ 1 ,   1 ],   [ 2 ,   1 ]]   ==   @ lambda   map   vcat ( _ ,   1 )   source  #  ChainMap.lambda     Function .  @unweave(f::Expr, e, v = :_)  lambda   e  then insert  e  as as the first and  v  as the last argument to  f .  f  must be a call.  Examples  e   =   :( _   +   1 )  f   =   :( NullableArrays . map ( lift   =   true ))  lambda ( f ,   e )  _   =   NullableArrays . NullableArray ([ 1 ,   2 ],   [ false ,   true ])  result   =   @ lambda   NullableArrays . broadcast ( lift   =   true )   _   +   1  @ test   result . values [ 1 ]   ==   2  @ test   result . isnull   ==   [ false ,   true ]  # `f` must be a call  @ test_throws   ErrorException   lambda (:( import   ChainMap ),   :( _   +   1 )   )   source  #  ChainMap.lambda     Method .  @lambda e  Convert  e  to an anonymous function with  _  as the input variable.  Examples  lambda_function   =   @ lambda   vcat ( _ ,   2 )  @ test   lambda_function ( 1 )   ==   vcat ( 1 ,   2 )   source  #  ChainMap.lazy_call     Method .  @lazy_call(e)  Will break apart a function call into a  LazyCall  object.  Examples  test_function ( arguments ... ;   keyword_arguments ... )   = \n     ( arguments ,   keyword_arguments )  @ test   (   @ lazy_call   test_function ( 1 ,   2 ,   a   =   3 )   )   == \n     collect_call ( test_function ,   1 ,   2 ,   a   =   3 )   source  #  ChainMap.nonstandard     Method .  @nonstandard(fs...)  Will create a nonstandard evaluation macro for each of the  fs  functions.  Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.  Examples  binaryfun ( a ,   b ,   c )   =   Expr (: call ,   b ,   a ,   c )  chainback ( a ,   b ,   c )   =   Expr (: call ,   c ,   b ,   a )  @ nonstandard   binaryfun   chainback  @ test   vcat ( 1 ,   2 )   ==   @ binaryfun   1   vcat   2  @ test   vcat ( 3 ,   2 )   ==   @ chainback   2   3   vcat  @ test   See documentation of [`binaryfun`](@ref)   == \n     @ chain   (@ doc   @ binaryfun )   string   chomp   source  #  ChainMap.push     Method .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to  arguments .  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  push_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     push ( _ ,   4 ,   a   =   5 ,   c   =   6 )  end  @ test   push_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source  #  ChainMap.push     Method .  push ( lazy_call : :LazyCall ,   positional ...;   keyword ...)   push  to  lazy_call.arguments .  Examples  push_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ]) \n     unshift ( _ ,   vcat ) \n     LazyCall ( _ ,   map ) \n     push ( _ ,   [ 3 ,   4 ]) \n     run  end  @ test   push_test   ==   [[ 1 ,   3 ],   [ 2 ,   4 ]]   source  #  ChainMap.unshift     Method .  unshift(arguments::Arguments, positional...)  Add positional arguments to  arguments .  New arguments are added at the start.  Examples  unshift_test   =   @ chain   begin \n     collect_arguments ( 2 ,   a   =   3 ) \n     unshift ( _ ,   1 )  end  @ test   unshift_test   ==   collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.unshift     Method .  unshift(lazy_call::LazyCall, positional...)  unshift  to  lazy_call.arguments .  Examples  unshift_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     LazyCall ( _ ,   map ) \n     unshift ( _ ,   vcat ) \n     run  end  @ test   unshift_test   ==   [[ 1 ,   3 ],   [ 2 ,   4 ]]   source  #  ChainMap.unweave     Method .  @unweave f e  unweave   e  then run  f  on the component parts.  If there are no woven arguments in  e , return  e .  Examples  @ test   1   ==   @ unweave   1   1  @ test   1   ==   @ unweave   1   + ( 1 )  e   =   :( vcat ( ~ a ,   ~ b )   )  f   =   : broadcast  unweave ( f ,   e )  a   =   [ 1 ,   2 ]  b   =   [ 3 ,   4 ]  @ test   broadcast (( a ,   b )   -   vcat ( a ,   b ),   a ,   b )   == \n     @ unweave   broadcast   vcat ( ~ a ,   ~ b )   source  #  ChainMap.unweave     Method .  @unweave f::Expr e  unweave   e  then insert the function as the first argument to  f  and the woven arguments at the end of the arguments of  f .  If there are no woven arguments in  e , return  e .  Examples  @ test   1   ==   @ unweave   + ( 1 )   1  @ test   1   ==   @ unweave   + ( 1 )   + ( 1 )  e   =   :( ~ a   +   ~ b )  f   =   :( NullableArrays . broadcast ( lift   =   true ))  unweave ( f ,   e )  a   =   NullableArrays . NullableArray ([ 1 ,   2 ])  b   =   NullableArrays . NullableArray ([ 3 ,   4 ],   [ false ,   true ])  result   =   @ unweave   broadcast ( lift   =   true )   ~ a   +   ~ b  @ test   result . values [ 1 ]   ==   4  @ test   result . isnull   ==   [ false ,   true ]  # `f` must be a call  @ test_throws   ErrorException   unweave (:( import   ChainMap ),   :( ~ _   +   1 )   )   source  #  ChainMap.unweave     Method .  @unweave e  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. No more than one splatted positional argument can be woven in. No more than one splatted keyword argument can be woven in provided there is a  ;  visible both inside and outside the tilda. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot . If there are no woven arguments in  e , return  e .  Examples  @ test   1   ==   @ unweave   1  @ test   1   ==   @ unweave   + ( 1 )  A   =   [ 1 ,   2 ]  B   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  unweave_test   =   @ chain   begin \n     @ unweave   vcat ( ~ A ,   ~ [ 3 ,   4 ],   ~ ( B ... )   ) \n     run ( _ ,   map )  end  @ test   unweave_test   == \n       map (( a ,   c ,   b ... )   -   vcat ( a ,   c ,   b ... ),   A ,   [ 3 ,   4 ],   B ... )  keyword_test (;   keyword_arguments ... )   =   keyword_arguments  a   =   keyword_test ( a   =   1 ,   b   =   2 )  unweave_keyword_test   =   @ chain   begin \n     @ unweave   keyword_test ( c   =   3 ;   ~ ( a ... )) \n     run  end  @ test   unweave_keyword_test   ==   keyword_test ( c   =   3 ;   a ...   )  # Can splat no more than one positional argument  @ test_throws   ErrorException   unweave (:(   ~ ( a ... )   +   ~ ( b ... )   ))  # Can splat no more than one keyword argument  @ test_throws   ErrorException   unweave (:(   ~ (; a ... )   +   ~ (; b ... )   ))   source  #  ChainMap.with     Function .  @with(e, df = _)  Extract any symbols  e , such as  :colA , from  df , e.g.  df[:colA] .  Anything wrapped in  ^ , such as  ^(expr) , gets passed through untouched.  Examples  a   =   1  _   =   DataFrames . DataFrame ( a   =   2 )  @ test   DataFrames . DataFrame ( b   =   _ [: a ]   +   a ,   c   =   : d )   == \n    @ with   DataFrames . DataFrame ( b   =   : a   +   a ,   c   =   ^ (: d ))   source  #  ChainMap.@chain     Macro .  See documentation of  chain  source  #  ChainMap.@chain_map     Macro .  See documentation of  chain_map  source  #  ChainMap.@lambda     Macro .  See documentation of  lambda  source  #  ChainMap.@lazy_call     Macro .  See documentation of  lazy_call  source  #  ChainMap.@nonstandard     Macro .  See documentation of  nonstandard  source  #  ChainMap.@unweave     Macro .  See documentation of  unweave  source  #  ChainMap.@with     Macro .  See documentation of  with  source", 
            "title": "ChainMap.jl"
        }
    ]
}