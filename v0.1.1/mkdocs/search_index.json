{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl\n\n\n\n\nChainMap.Arguments\n\n\nChainMap.LazyCall\n\n\nBase.merge\n\n\nBase.merge\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nChainMap.bitnot\n\n\nChainMap.chain\n\n\nChainMap.chain_line\n\n\nChainMap.chain_map\n\n\nChainMap.collect_arguments\n\n\nChainMap.collect_call\n\n\nChainMap.lambda\n\n\nChainMap.lambda\n\n\nChainMap.lambda\n\n\nChainMap.lazy_call\n\n\nChainMap.link\n\n\nChainMap.link\n\n\nChainMap.nonstandard\n\n\nChainMap.push\n\n\nChainMap.push\n\n\nChainMap.unshift\n\n\nChainMap.unshift\n\n\nChainMap.unweave\n\n\nChainMap.unweave\n\n\nChainMap.unweave\n\n\nChainMap.with\n\n\nChainMap.@broadcast\n\n\nChainMap.@chain\n\n\nChainMap.@chain_line\n\n\nChainMap.@chain_map\n\n\nChainMap.@lambda\n\n\nChainMap.@lazy_call\n\n\nChainMap.@link\n\n\nChainMap.@map\n\n\nChainMap.@nonstandard\n\n\nChainMap.@unweave\n\n\nChainMap.@with\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\ntype Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use.\n\n\nCreate with \ncollect_arguments\n. You can also \nmerge\n two \nArguments\n, \npush\n or \nunshift\n in new arguments, and run with \nrun\n.\n\n\nsource\n\n\n#\n\n\nChainMap.LazyCall\n \n \nType\n.\n\n\ntype LazyCall{T \n: Function}\n    arguments::Arguments\n    function_call::T\nend\n\n\n\n\n\nWill store a function along with its arguments for later use. Create with \ncollect_call\n and run with \nrun\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments, f::Function)\n\n\n\n\n\nCall \nf\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nrun\n(\n_\n,\n \nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments)\n\n\n\n\n\nCall \nrun\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \ncollect_arguments\n(\n_\n,\n \nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall, f::Function)\n\n\n\n\n\nInsert \nl.function_call\n as the first positional argument in \nl.arguments\n, the standard position for functional programming, then \nrun\n \nf\n on the result.\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n4\n])\n\n    \nLazyCall\n(\n_\n,\n \nvcat\n)\n\n    \nrun\n(\n_\n,\n \nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall)\n\n\n\n\n\nCall \nl.function_call\n on the \nArguments\n in \nl.arguments\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@unweave\n\n\nExamples\n\n\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain e::Expr\n\n\n\n\n\nSeparate \nbegin\n blocks out into lines and \nchain_line\n them.\n\n\ne\n must be a \nbegin\n block. Note that dot fusion is broken by this macro. Instead, use \nunweave\n, \n@map\n, or \n@broadcast\n.\n\n\nExamples\n\n\nchain_block\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \nvcat\n(\n_\n,\n \n2\n)\n\n\nend\n\n\n\n@\ntest\n \nchain_block\n \n==\n \n@\nchain_line\n \n1\n \nvcat\n(\n_\n,\n \n2\n)\n\n\n\n@\ntest_throws\n \nErrorException\n \nChainMap\n.\nchain\n(:(\na\n \n+\n \nb\n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain_line\n \n \nMethod\n.\n\n\n@chain_line es...\n\n\n\n\n\nreduce\n \nlink\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain_line\n \n1\n \nvcat\n(\n_\n,\n \n2\n)\n \nvcat\n(\n_\n,\n \n3\n)\n \n)\n \n==\n\n    \n@\nlink\n \n(\n \n@\nlink\n \n1\n \nvcat\n(\n_\n,\n \n2\n)\n \n)\n \nvcat\n(\n_\n,\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain_map\n \n \nFunction\n.\n\n\n@chain_map(e, associative = _)\n\n\n\n\n\nThe \n@chain_map\n macro combines three different macros.\n\n\nwith\n annotates each symbol with \nassociative\n. \nchain\n chains together expressions wrapped in a \nbegin\n block. \n@broadcast\n does broadcasting of woven expressions.\n\n\nIf a problem is encountered using one of the three macros (i.e. it isn't applicaple) that macro is ignored.\n\n\nExamples\n\n\ne\n \n=\n \nquote\n\n    \n:\nb\n\n    \nsum\n\n    \nstring\n\n    \n*\n(\n~\na\n,\n \n \n,\n \n_\n,\n \n \n,\n \n~\n:\nc\n)\n\n\nend\n\n\n\na\n \n=\n \n[\none\n,\n \ntwo\n]\n\n\nresult\n \n=\n \n@\nchain\n \nbegin\n\n    \nDict\n(:\nb\n \n=\n \n[\n1\n,\n \n2\n],\n \n:\nc\n \n=\n \n[\nI\n,\n \nII\n])\n\n    \n@\nchain_map\n \nbegin\n\n        \n:\nb\n\n        \nsum\n\n        \nstring\n\n        \n*\n(\n~\na\n,\n \n \n,\n \n_\n,\n \n \n,\n \n~\n:\nc\n)\n\n    \nend\n\n\nend\n\n\n\n@\ntest\n \nresult\n \n==\n \n[\none 3 I\n,\n \ntwo 3 II\n]\n\n\n\n@\ntest\n \n1\n \n==\n \n@\nchain_map\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_arguments\n \n \nMethod\n.\n\n\ncollect_arguments(positional...; keyword...)\n\n\n\n\n\nEasy way to build an \nArguments\n type.\n\n\nExamples\n\n\na\n \n=\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n@\ntest\n \na\n.\npositional\n \n==\n \n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \na\n.\nkeyword\n \n==\n \nDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_call\n \n \nMethod\n.\n\n\ncollect_call\n(\nf\n:\n:Function\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nEasy way to build a \nLazyCall\n type.\n\n\nExamples\n\n\nl\n \n=\n \ncollect_call\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n@\ntest\n \nl\n.\nfunction_call\n \n==\n \nvcat\n\n\n@\ntest\n \nl\n.\narguments\n \n==\n \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nFunction\n.\n\n\n@lambda(outer_function::Symbol, anonymous_function::Expr, input = :_)\n\n\n\n\n\nlambda\n \nanonymous_function\n then call \nouter_function\n on \nanonymous_function\n and \ninput\n.\n\n\nExamples\n\n\nouter_function\n \n=\n \n:\nmap\n\n\nanonymous_function\n \n=\n \n:(\nvcat\n(\n_\n,\n \n1\n))\n\n\nlambda\n(\nouter_function\n,\n \nanonymous_function\n)\n\n\n\n_\n \n=\n \n[\n1\n,\n \n2\n]\n\n\n@\ntest\n \nmap\n(\n_\n \n-\n \nvcat\n(\n_\n,\n \n1\n),\n \n_\n)\n \n==\n \n@\nlambda\n \nmap\n \nvcat\n(\n_\n,\n \n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nFunction\n.\n\n\n@lambda(outer_function::Expr, anonymous_function::Expr, input = _)\n\n\n\n\n\nlambda\n \nanonymous_function\n then insert \nanonymous_function\n as as the first and \ninput\n as the last argument to \nouter_function\n.\n\n\nouter_function\n must be a call.\n\n\nExamples\n\n\nanonymous_function\n \n=\n \n:(\n_\n \n+\n \n1\n)\n\n\nouter_function\n \n=\n \n:(\n \nmapreduce\n(\n*\n)\n \n)\n\n\n\nlambda\n(\nouter_function\n,\n \nanonymous_function\n)\n\n\n\n_\n \n=\n \n[\n1\n,\n \n2\n]\n\n\n\n@\ntest\n \nmapreduce\n(\nx\n \n-\n \nx\n \n+\n \n1\n,\n \n*\n,\n \n[\n1\n,\n \n2\n])\n \n==\n\n  \n@\nlambda\n \nmapreduce\n(\n*\n)\n \n_\n \n+\n \n1\n\n\n\n# `f` must be a call\n\n\n@\ntest_throws\n \nErrorException\n \nlambda\n(:(\nimport\n \nChainMap\n),\n \n:(\n_\n \n+\n \n1\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nMethod\n.\n\n\n@lambda anonymous_function::Expr\n\n\n\n\n\nConvert \nanonymous_function\n to an anonymous function with \n_\n as the input variable.\n\n\nExamples\n\n\nlambda_function\n \n=\n \n@\nlambda\n \nvcat\n(\n_\n,\n \n2\n)\n\n\n@\ntest\n \nlambda_function\n(\n1\n)\n \n==\n \nvcat\n(\n1\n,\n \n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lazy_call\n \n \nMethod\n.\n\n\n@lazy_call(function_call)\n\n\n\n\n\nWill break apart a \nfunction_call\n into a \nLazyCall\n object.\n\n\nExamples\n\n\ntest_function\n(\narguments\n...\n;\n \nkeyword_arguments\n...\n)\n \n=\n\n    \n(\narguments\n,\n \nkeyword_arguments\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \ntest_function\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n \n)\n \n==\n\n    \ncollect_call\n(\ntest_function\n,\n \n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.link\n \n \nMethod\n.\n\n\n@link head tail::Expr\n\n\n\n\n\nReinterprets \n_\n in \ntail\n as \nhead\n.\n\n\nExamples\n\n\n@\ntest\n \nvcat\n(\n2\n,\n \n1\n)\n \n==\n \n@\nlink\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.link\n \n \nMethod\n.\n\n\n@link head tail::Symbol\n\n\n\n\n\nCalls \nhead\n on \ntail\n\n\nExamples\n\n\n@\ntest\n \nvcat\n(\n1\n)\n \n==\n \n@\nlink\n \n1\n \nvcat\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.nonstandard\n \n \nMethod\n.\n\n\n@nonstandard(function_calls...)\n\n\n\n\n\nWill create a nonstandard evaluation macro for each of the \nfunction_calls\n.\n\n\nEach function should be a function that takes and returns expressions. The nonstandard macro will have the same name. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.\n\n\nExamples\n\n\nnonstandard\n(:\nbinary_function\n,\n \n:\nchain_back\n)\n\n\n\nbinary_function\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \nExpr\n(:\ncall\n,\n \nb\n,\n \na\n,\n \nc\n)\n\n\nchain_back\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \nExpr\n(:\ncall\n,\n \nc\n,\n \nb\n,\n \na\n)\n\n\n\n@\nnonstandard\n \nbinary_function\n \nchain_back\n\n\n\n@\ntest\n \nvcat\n(\n1\n,\n \n2\n)\n \n==\n \n@\nbinary_function\n \n1\n \nvcat\n \n2\n\n\n@\ntest\n \nvcat\n(\n3\n,\n \n2\n)\n \n==\n \n@\nchain_back\n \n2\n \n3\n \nvcat\n\n\n\n@\ntest\n \nSee documentation of [`binary_function`](@ref)\n \n==\n\n    \n@\nchain_line\n \n(@\ndoc\n \n@\nbinary_function\n)\n \nstring\n \nchomp\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to \narguments\n.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \npush\n(\n_\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\nlazy_call\n:\n:LazyCall\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\npush\n to \nlazy_call.arguments\n.\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \npush\n(\n_\n,\n \n[\n3\n,\n \n4\n])\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \n[[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n4\n]]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to \narguments\n.\n\n\nNew arguments are added at the start.\n\n\nExamples\n\n\nunshift_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n    \nunshift\n(\n_\n,\n \n1\n)\n\n\nend\n\n\n\n@\ntest\n \nunshift_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(lazy_call::LazyCall, positional...)\n\n\n\n\n\nunshift\n to \nlazy_call.arguments\n.\n\n\nExamples\n\n\nunshift_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nunshift_test\n \n==\n \n[[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n4\n]]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave f::Expr e::Expr\n\n\n\n\n\nunweave\n \ne\n then insert the function as the first argument to \nf\n and the woven arguments at the end of the arguments of \nf\n.\n\n\nIf there are no woven arguments in \ne\n, return \ne\n.\n\n\nExamples\n\n\nbroadcast_tuple\n(\nargs\n...\n;\n \nas_tuple\n \n=\n \nfalse\n)\n \n=\n\n    \nif\n \nas_tuple\n\n        \n(\nbroadcast\n(\nargs\n...\n)\n...\n)\n\n    \nelse\n\n        \nbroadcast\n(\nargs\n...\n)\n\n    \nend\n\n\n\ne\n \n=\n \n:(\n \nvcat\n(\n~\na\n,\n \n~\nb\n)\n \n)\n\n\nf\n \n=\n \n:(\nbroadcast_tuple\n(\nas_tuple\n \n=\n \ntrue\n)\n \n)\n\n\n\nunweave\n(\nf\n,\n \ne\n)\n\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n[\n3\n,\n \n4\n]\n\n\n\nresult\n \n=\n \n@\nunweave\n \nbroadcast_tuple\n(\nas_tuple\n \n=\n \ntrue\n)\n \n~\na\n \n+\n \n~\nb\n\n\n\n@\ntest\n \nbroadcast_tuple\n(\n \n(\na\n,\n \nb\n)\n \n-\n \nvcat\n(\na\n,\n \nb\n),\n \na\n,\n \nb\n,\n \nas_tuple\n \n=\n \ntrue\n)\n \n==\n\n    \n@\nunweave\n \nbroadcast_tuple\n(\nas_tuple\n \n=\n \ntrue\n)\n \nvcat\n(\n~\na\n,\n \n~\nb\n)\n\n\n\n# `f` must be a call\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\nimport\n \nChainMap\n),\n \n:(\n~\n_\n \n+\n \n1\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave e::Expr\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. No more than one splatted positional argument can be woven in. No more than one splatted keyword argument can be woven in provided there is a \n;\n visible both inside and outside the tilda. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n. If there are no woven arguments in \ne\n, return \ne\n.\n\n\nExamples\n\n\nA\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nB\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\nunweave_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n@\nunweave\n \nvcat\n(\n~\nA\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nB\n...\n)\n \n)\n\n    \nrun\n(\n_\n,\n \nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nunweave_test\n \n==\n\n      \nmap\n((\na\n,\n \nc\n,\n \nb\n...\n)\n \n-\n \nvcat\n(\na\n,\n \nc\n,\n \nb\n...\n),\n \nA\n,\n \n[\n3\n,\n \n4\n],\n \nB\n...\n)\n\n\n\nkeyword_test\n(;\n \nkeyword_arguments\n...\n)\n \n=\n \nkeyword_arguments\n\n\n\na\n \n=\n \nkeyword_test\n(\na\n \n=\n \n1\n,\n \nb\n \n=\n \n2\n)\n\n\n\nunweave_keyword_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n@\nunweave\n \nkeyword_test\n(\nc\n \n=\n \n3\n;\n \n~\n(\na\n...\n))\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nunweave_keyword_test\n \n==\n \nkeyword_test\n(\nc\n \n=\n \n3\n;\n \na\n...\n \n)\n\n\n\n# Must include at least one woven argument\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\na\n \n+\n \nb\n))\n\n\n\n# Can splat no more than one positional argument\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\n \n~\n(\na\n...\n)\n \n+\n \n~\n(\nb\n...\n)\n \n))\n\n\n\n# Can splat no more than one keyword argument\n\n\n@\ntest_throws\n \nErrorException\n \nunweave\n(:(\n \n~\n(;\na\n...\n)\n \n+\n \n~\n(;\nb\n...\n)\n \n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave f::Symbol e::Expr\n\n\n\n\n\nunweave\n \ne\n then run \nf\n on the component parts, anonymous function first.\n\n\nExamples\n\n\ne\n \n=\n \n:(\nvcat\n(\n~\na\n,\n \n~\nb\n)\n \n)\n\n\nf\n \n=\n \n:\nbroadcast\n\n\nunweave\n(\nf\n,\n \ne\n)\n\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n[\n3\n,\n \n4\n]\n\n\n\n@\ntest\n \nbroadcast\n((\na\n,\n \nb\n)\n \n-\n \nvcat\n(\na\n,\n \nb\n),\n \na\n,\n \nb\n)\n \n==\n\n    \n@\nunweave\n \nbroadcast\n \nvcat\n(\n~\na\n,\n \n~\nb\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.with\n \n \nFunction\n.\n\n\n@with(e, associative = _)\n\n\n\n\n\nExtract any symbols in \ne\n, such as \n:a\n, from \nassociative\n, e.g. \nassociative[:a]\n.\n\n\nAnything wrapped in \n^\n, such as \n^(escaped)\n, gets passed through untouched.\n\n\nExamples\n\n\na\n \n=\n \n1\n\n\n_\n \n=\n \nDict\n(:\na\n \n=\n \n2\n)\n\n\n\n@\ntest\n \nDict\n(\na\n \n=\n \n_\n[:\na\n]\n \n+\n \na\n,\n \nb\n \n=\n \n:\nb\n)\n \n==\n\n   \n@\nwith\n \nDict\n(\na\n \n=\n \n:\na\n \n+\n \na\n,\n \nb\n \n=\n \n^\n(:\nb\n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@broadcast\n \n \nMacro\n.\n\n\n@broadcast e::Expr\n\n\n\n\n\nA convenience macro for \nunweave\nwhere\nf\n=\nbroadcast`\n\n\nExamples\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n[\n3\n,\n \n4\n]\n\n\n\n@\ntest\n \nbroadcast\n((\na\n,\n \nb\n)\n \n-\n \nvcat\n(\na\n,\n \nb\n),\n \na\n,\n \nb\n)\n \n==\n\n    \n@\nbroadcast\n \nvcat\n(\n~\na\n,\n \n~\nb\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\nSee documentation of \nchain\n\n\nsource\n\n\n#\n\n\nChainMap.@chain_line\n \n \nMacro\n.\n\n\nSee documentation of \nchain_line\n\n\nsource\n\n\n#\n\n\nChainMap.@chain_map\n \n \nMacro\n.\n\n\nSee documentation of \nchain_map\n\n\nsource\n\n\n#\n\n\nChainMap.@lambda\n \n \nMacro\n.\n\n\nSee documentation of \nlambda\n\n\nsource\n\n\n#\n\n\nChainMap.@lazy_call\n \n \nMacro\n.\n\n\nSee documentation of \nlazy_call\n\n\nsource\n\n\n#\n\n\nChainMap.@link\n \n \nMacro\n.\n\n\nSee documentation of \nlink\n\n\nsource\n\n\n#\n\n\nChainMap.@map\n \n \nMacro\n.\n\n\n@map(anonymous_function::Expr, input = _)\n\n\n\n\n\nA convenience macro for \nlambda\n where \nouter_function\n = \nmap\n\n\nExamples\n\n\n_\n \n=\n \n[\n1\n,\n \n2\n]\n\n\n@\ntest\n \nmap\n(\n_\n \n-\n \nvcat\n(\n_\n,\n \n1\n),\n \n_\n)\n \n==\n \n@\nmap\n \nvcat\n(\n_\n,\n \n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\nSee documentation of \nnonstandard\n\n\nsource\n\n\n#\n\n\nChainMap.@unweave\n \n \nMacro\n.\n\n\nSee documentation of \nunweave\n\n\nsource\n\n\n#\n\n\nChainMap.@with\n \n \nMacro\n.\n\n\nSee documentation of \nwith\n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nmerge(a::Arguments, b::Arguments)\n\n\n\n\n\nMerge two \nArguments\n types.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\nmerge_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \nmerge\n(\n_\n,\n \ncollect_arguments\n(\n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n \n)\n\n\nend\n\n\n\n@\ntest\n \nmerge_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nmerge(lazy_call::LazyCall, arguments::Arguments)\n\n\n\n\n\nmerge\n \narguments\n into the \narguments\n of \nlazy_call\n.\n\n\nExamples\n\n\nmerge_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n])\n\n    \nunshift\n(\n_\n,\n \nvcat\n)\n\n    \nLazyCall\n(\n_\n,\n \nmap\n)\n\n    \nmerge\n(\n_\n,\n \ncollect_arguments\n([\n3\n,\n \n4\n])\n \n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nmerge_test\n \n==\n \n[[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n4\n]]\n\n\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl", 
            "text": "ChainMap.Arguments  ChainMap.LazyCall  Base.merge  Base.merge  Base.run  Base.run  Base.run  Base.run  ChainMap.bitnot  ChainMap.chain  ChainMap.chain_line  ChainMap.chain_map  ChainMap.collect_arguments  ChainMap.collect_call  ChainMap.lambda  ChainMap.lambda  ChainMap.lambda  ChainMap.lazy_call  ChainMap.link  ChainMap.link  ChainMap.nonstandard  ChainMap.push  ChainMap.push  ChainMap.unshift  ChainMap.unshift  ChainMap.unweave  ChainMap.unweave  ChainMap.unweave  ChainMap.with  ChainMap.@broadcast  ChainMap.@chain  ChainMap.@chain_line  ChainMap.@chain_map  ChainMap.@lambda  ChainMap.@lazy_call  ChainMap.@link  ChainMap.@map  ChainMap.@nonstandard  ChainMap.@unweave  ChainMap.@with   #  ChainMap.Arguments     Type .  type Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend  Will store positional and keyword arguments for later use.  Create with  collect_arguments . You can also  merge  two  Arguments ,  push  or  unshift  in new arguments, and run with  run .  source  #  ChainMap.LazyCall     Type .  type LazyCall{T  : Function}\n    arguments::Arguments\n    function_call::T\nend  Will store a function along with its arguments for later use. Create with  collect_call  and run with  run  source  #  Base.run     Method .   run(a::Arguments, f::Function)  Call  f  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( _ ,   vcat ) \n     run ( _ ,   map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(a::Arguments)  Call  run  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( _ ,   vcat ) \n     collect_arguments ( _ ,   map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall, f::Function)  Insert  l.function_call  as the first positional argument in  l.arguments , the standard position for functional programming, then  run   f  on the result.  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 , 4 ]) \n     LazyCall ( _ ,   vcat ) \n     run ( _ ,   map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall)  Call  l.function_call  on the  Arguments  in  l.arguments  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( _ ,   vcat ) \n     LazyCall ( _ ,   map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @unweave  Examples  @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.chain     Method .  @chain e::Expr  Separate  begin  blocks out into lines and  chain_line  them.  e  must be a  begin  block. Note that dot fusion is broken by this macro. Instead, use  unweave ,  @map , or  @broadcast .  Examples  chain_block   =   @ chain   begin \n     1 \n     vcat ( _ ,   2 )  end  @ test   chain_block   ==   @ chain_line   1   vcat ( _ ,   2 )  @ test_throws   ErrorException   ChainMap . chain (:( a   +   b ))   source  #  ChainMap.chain_line     Method .  @chain_line es...  reduce   link  over  es  Examples  @ test   (   @ chain_line   1   vcat ( _ ,   2 )   vcat ( _ ,   3 )   )   == \n     @ link   (   @ link   1   vcat ( _ ,   2 )   )   vcat ( _ ,   3 )   source  #  ChainMap.chain_map     Function .  @chain_map(e, associative = _)  The  @chain_map  macro combines three different macros.  with  annotates each symbol with  associative .  chain  chains together expressions wrapped in a  begin  block.  @broadcast  does broadcasting of woven expressions.  If a problem is encountered using one of the three macros (i.e. it isn't applicaple) that macro is ignored.  Examples  e   =   quote \n     : b \n     sum \n     string \n     * ( ~ a ,     ,   _ ,     ,   ~ : c )  end  a   =   [ one ,   two ]  result   =   @ chain   begin \n     Dict (: b   =   [ 1 ,   2 ],   : c   =   [ I ,   II ]) \n     @ chain_map   begin \n         : b \n         sum \n         string \n         * ( ~ a ,     ,   _ ,     ,   ~ : c ) \n     end  end  @ test   result   ==   [ one 3 I ,   two 3 II ]  @ test   1   ==   @ chain_map   1   source  #  ChainMap.collect_arguments     Method .  collect_arguments(positional...; keyword...)  Easy way to build an  Arguments  type.  Examples  a   =   collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  @ test   a . positional   ==   ( 1 ,   2 )  @ test   a . keyword   ==   Dict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  ChainMap.collect_call     Method .  collect_call ( f : :Function ,   positional ...;   keyword ...)   Easy way to build a  LazyCall  type.  Examples  l   =   collect_call ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])  @ test   l . function_call   ==   vcat  @ test   l . arguments   ==   collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.lambda     Function .  @lambda(outer_function::Symbol, anonymous_function::Expr, input = :_)  lambda   anonymous_function  then call  outer_function  on  anonymous_function  and  input .  Examples  outer_function   =   : map  anonymous_function   =   :( vcat ( _ ,   1 ))  lambda ( outer_function ,   anonymous_function )  _   =   [ 1 ,   2 ]  @ test   map ( _   -   vcat ( _ ,   1 ),   _ )   ==   @ lambda   map   vcat ( _ ,   1 )   source  #  ChainMap.lambda     Function .  @lambda(outer_function::Expr, anonymous_function::Expr, input = _)  lambda   anonymous_function  then insert  anonymous_function  as as the first and  input  as the last argument to  outer_function .  outer_function  must be a call.  Examples  anonymous_function   =   :( _   +   1 )  outer_function   =   :(   mapreduce ( * )   )  lambda ( outer_function ,   anonymous_function )  _   =   [ 1 ,   2 ]  @ test   mapreduce ( x   -   x   +   1 ,   * ,   [ 1 ,   2 ])   == \n   @ lambda   mapreduce ( * )   _   +   1  # `f` must be a call  @ test_throws   ErrorException   lambda (:( import   ChainMap ),   :( _   +   1 )   )   source  #  ChainMap.lambda     Method .  @lambda anonymous_function::Expr  Convert  anonymous_function  to an anonymous function with  _  as the input variable.  Examples  lambda_function   =   @ lambda   vcat ( _ ,   2 )  @ test   lambda_function ( 1 )   ==   vcat ( 1 ,   2 )   source  #  ChainMap.lazy_call     Method .  @lazy_call(function_call)  Will break apart a  function_call  into a  LazyCall  object.  Examples  test_function ( arguments ... ;   keyword_arguments ... )   = \n     ( arguments ,   keyword_arguments )  @ test   (   @ lazy_call   test_function ( 1 ,   2 ,   a   =   3 )   )   == \n     collect_call ( test_function ,   1 ,   2 ,   a   =   3 )   source  #  ChainMap.link     Method .  @link head tail::Expr  Reinterprets  _  in  tail  as  head .  Examples  @ test   vcat ( 2 ,   1 )   ==   @ link   1   vcat ( 2 ,   _ )   source  #  ChainMap.link     Method .  @link head tail::Symbol  Calls  head  on  tail  Examples  @ test   vcat ( 1 )   ==   @ link   1   vcat   source  #  ChainMap.nonstandard     Method .  @nonstandard(function_calls...)  Will create a nonstandard evaluation macro for each of the  function_calls .  Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.  Examples  nonstandard (: binary_function ,   : chain_back )  binary_function ( a ,   b ,   c )   =   Expr (: call ,   b ,   a ,   c )  chain_back ( a ,   b ,   c )   =   Expr (: call ,   c ,   b ,   a )  @ nonstandard   binary_function   chain_back  @ test   vcat ( 1 ,   2 )   ==   @ binary_function   1   vcat   2  @ test   vcat ( 3 ,   2 )   ==   @ chain_back   2   3   vcat  @ test   See documentation of [`binary_function`](@ref)   == \n     @ chain_line   (@ doc   @ binary_function )   string   chomp   source  #  ChainMap.push     Method .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to  arguments .  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  push_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     push ( _ ,   4 ,   a   =   5 ,   c   =   6 )  end  @ test   push_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source  #  ChainMap.push     Method .  push ( lazy_call : :LazyCall ,   positional ...;   keyword ...)   push  to  lazy_call.arguments .  Examples  push_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ]) \n     unshift ( _ ,   vcat ) \n     LazyCall ( _ ,   map ) \n     push ( _ ,   [ 3 ,   4 ]) \n     run  end  @ test   push_test   ==   [[ 1 ,   3 ],   [ 2 ,   4 ]]   source  #  ChainMap.unshift     Method .  unshift(arguments::Arguments, positional...)  Add positional arguments to  arguments .  New arguments are added at the start.  Examples  unshift_test   =   @ chain   begin \n     collect_arguments ( 2 ,   a   =   3 ) \n     unshift ( _ ,   1 )  end  @ test   unshift_test   ==   collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.unshift     Method .  unshift(lazy_call::LazyCall, positional...)  unshift  to  lazy_call.arguments .  Examples  unshift_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     LazyCall ( _ ,   map ) \n     unshift ( _ ,   vcat ) \n     run  end  @ test   unshift_test   ==   [[ 1 ,   3 ],   [ 2 ,   4 ]]   source  #  ChainMap.unweave     Method .  @unweave f::Expr e::Expr  unweave   e  then insert the function as the first argument to  f  and the woven arguments at the end of the arguments of  f .  If there are no woven arguments in  e , return  e .  Examples  broadcast_tuple ( args ... ;   as_tuple   =   false )   = \n     if   as_tuple \n         ( broadcast ( args ... ) ... ) \n     else \n         broadcast ( args ... ) \n     end  e   =   :(   vcat ( ~ a ,   ~ b )   )  f   =   :( broadcast_tuple ( as_tuple   =   true )   )  unweave ( f ,   e )  a   =   [ 1 ,   2 ]  b   =   [ 3 ,   4 ]  result   =   @ unweave   broadcast_tuple ( as_tuple   =   true )   ~ a   +   ~ b  @ test   broadcast_tuple (   ( a ,   b )   -   vcat ( a ,   b ),   a ,   b ,   as_tuple   =   true )   == \n     @ unweave   broadcast_tuple ( as_tuple   =   true )   vcat ( ~ a ,   ~ b )  # `f` must be a call  @ test_throws   ErrorException   unweave (:( import   ChainMap ),   :( ~ _   +   1 )   )   source  #  ChainMap.unweave     Method .  @unweave e::Expr  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. No more than one splatted positional argument can be woven in. No more than one splatted keyword argument can be woven in provided there is a  ;  visible both inside and outside the tilda. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot . If there are no woven arguments in  e , return  e .  Examples  A   =   [ 1 ,   2 ]  B   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  unweave_test   =   @ chain   begin \n     @ unweave   vcat ( ~ A ,   ~ [ 3 ,   4 ],   ~ ( B ... )   ) \n     run ( _ ,   map )  end  @ test   unweave_test   == \n       map (( a ,   c ,   b ... )   -   vcat ( a ,   c ,   b ... ),   A ,   [ 3 ,   4 ],   B ... )  keyword_test (;   keyword_arguments ... )   =   keyword_arguments  a   =   keyword_test ( a   =   1 ,   b   =   2 )  unweave_keyword_test   =   @ chain   begin \n     @ unweave   keyword_test ( c   =   3 ;   ~ ( a ... )) \n     run  end  @ test   unweave_keyword_test   ==   keyword_test ( c   =   3 ;   a ...   )  # Must include at least one woven argument  @ test_throws   ErrorException   unweave (:( a   +   b ))  # Can splat no more than one positional argument  @ test_throws   ErrorException   unweave (:(   ~ ( a ... )   +   ~ ( b ... )   ))  # Can splat no more than one keyword argument  @ test_throws   ErrorException   unweave (:(   ~ (; a ... )   +   ~ (; b ... )   ))   source  #  ChainMap.unweave     Method .  @unweave f::Symbol e::Expr  unweave   e  then run  f  on the component parts, anonymous function first.  Examples  e   =   :( vcat ( ~ a ,   ~ b )   )  f   =   : broadcast  unweave ( f ,   e )  a   =   [ 1 ,   2 ]  b   =   [ 3 ,   4 ]  @ test   broadcast (( a ,   b )   -   vcat ( a ,   b ),   a ,   b )   == \n     @ unweave   broadcast   vcat ( ~ a ,   ~ b )   source  #  ChainMap.with     Function .  @with(e, associative = _)  Extract any symbols in  e , such as  :a , from  associative , e.g.  associative[:a] .  Anything wrapped in  ^ , such as  ^(escaped) , gets passed through untouched.  Examples  a   =   1  _   =   Dict (: a   =   2 )  @ test   Dict ( a   =   _ [: a ]   +   a ,   b   =   : b )   == \n    @ with   Dict ( a   =   : a   +   a ,   b   =   ^ (: b ))   source  #  ChainMap.@broadcast     Macro .  @broadcast e::Expr  A convenience macro for  unweave where f = broadcast`  Examples  a   =   [ 1 ,   2 ]  b   =   [ 3 ,   4 ]  @ test   broadcast (( a ,   b )   -   vcat ( a ,   b ),   a ,   b )   == \n     @ broadcast   vcat ( ~ a ,   ~ b )   source  #  ChainMap.@chain     Macro .  See documentation of  chain  source  #  ChainMap.@chain_line     Macro .  See documentation of  chain_line  source  #  ChainMap.@chain_map     Macro .  See documentation of  chain_map  source  #  ChainMap.@lambda     Macro .  See documentation of  lambda  source  #  ChainMap.@lazy_call     Macro .  See documentation of  lazy_call  source  #  ChainMap.@link     Macro .  See documentation of  link  source  #  ChainMap.@map     Macro .  @map(anonymous_function::Expr, input = _)  A convenience macro for  lambda  where  outer_function  =  map  Examples  _   =   [ 1 ,   2 ]  @ test   map ( _   -   vcat ( _ ,   1 ),   _ )   ==   @ map   vcat ( _ ,   1 )   source  #  ChainMap.@nonstandard     Macro .  See documentation of  nonstandard  source  #  ChainMap.@unweave     Macro .  See documentation of  unweave  source  #  ChainMap.@with     Macro .  See documentation of  with  source  #  Base.merge     Method .  merge(a::Arguments, b::Arguments)  Merge two  Arguments  types.  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  merge_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     merge ( _ ,   collect_arguments ( 4 ,   a   =   5 ,   c   =   6 )   )  end  @ test   merge_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source  #  Base.merge     Method .  merge(lazy_call::LazyCall, arguments::Arguments)  merge   arguments  into the  arguments  of  lazy_call .  Examples  merge_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ]) \n     unshift ( _ ,   vcat ) \n     LazyCall ( _ ,   map ) \n     merge ( _ ,   collect_arguments ([ 3 ,   4 ])   ) \n     run  end  @ test   merge_test   ==   [[ 1 ,   3 ],   [ 2 ,   4 ]]   source", 
            "title": "ChainMap.jl"
        }
    ]
}